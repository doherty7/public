/*
 * DEXTUploadX5 - common library
 * http://www.dextsolution.com
 *
 * Using MDN content
 * https://developer.mozilla.org/en-US/docs/MDN/About#Copyrights_and_licenses
 * http://creativecommons.org/licenses/by-sa/2.5/deed.ko
 *
 * "About MDN by Mozilla Contributors is licensed under CC-BY-SA 2.5."
 *
 * Includes MDN(Mozillar Deveolper Network) polyfill libraries
 *   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from
 *
 * Copyright DEVPIA Inc.
 */
function isDefined(t) { return typeof(t) != "undefined"; } if (typeof Array.isArray === "undefined") { Array.isArray = function (arg) { return Object.prototype.toString.call(arg) === "[object Array]"; }; } if (!Array.from) { Array.from = (function () { var toStr = Object.prototype.toString; var isCallable = function (fn) { return typeof fn === 'function' || toStr.call(fn) === '[object Function]'; }; var toInteger = function (value) { var number = Number(value); if (isNaN(number)) { return 0; } if (number === 0 || !isFinite(number)) { return number; } return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}; var maxSafeInteger = Math.pow(2, 53) - 1; var toLength = function (value) { var len = toInteger(value); return Math.min(Math.max(len, 0), maxSafeInteger); };   return function from(arrayLike) {   var C = this;   var items = Object(arrayLike);   if (arrayLike == null) { throw new TypeError("Array.from requires an array-like object - not null or undefined"); }   var mapFn = arguments.length > 1 ? arguments[1] : void undefined; var T; if (typeof mapFn !== 'undefined') {     if (!isCallable(mapFn)) { throw new TypeError('Array.from: when provided, the second argument must be a function');
}   if (arguments.length > 2) { T = arguments[2]; } }     var len = toLength(items.length);       var A = isCallable(C) ? Object(new C(len)) : new Array(len);   var k = 0;   var kValue; while (k < len) { kValue = items[k]; if (mapFn) { A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k); } else { A[k] = kValue; } k += 1; }   A.length = len;   return A; }; }()); } function trim(str) {  return str ? str.replace(/(^\s*)|(\s*$)/gi, "") : ""; } function sformat(fmt, reps) { var s = fmt; for (var i = 0; i < reps.length; i++) {
var rex = new RegExp("\\{" + i + "\\}", "gm"); s = s.replace(rex, reps[i]); } return s; }; function getIdSharp(id, use) { var sharp = (id && id.indexOf("#") == 0) ? true : false; if (sharp && use) return id; else if (sharp && !use) return id.substring(1); else if (!sharp && use) return "#" + id; else return id; } function detectBrowser() { var ag = navigator.userAgent, match = null, rs = { "isOpera": false, "isFirefox": false, "isSafari": false, "isChrome": false, "isIE": false, "isEdge": false, "isUnKnown": false, "version": "0" };  
    if (!!window.opr || !!window.opera || ag.indexOf(' OPR/') >= 0) { rs.isOpera = true; match = ag.match(/ OPR\/([0-9]+)\./); rs.version = match ? match[1] : "8"; return rs; }   if (typeof InstallTrigger !== 'undefined') { rs.isFirefox = true; match = ag.match(/Firefox\/([0-9]+)\./); rs.version = match ? match[1] : "1"; return rs; }   if (/constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || safari.pushNotification)) { rs.isSafari = true;
match = ag.match(/ Version\/([0-9]+)\./); rs.version = match ? match[1] : "3"; return rs; }   if (false || !!document.documentMode) { rs.isIE = true; match = ag.match(/MSIE ([0-9]+)\./); if (match) rs.version = match[1]; else if (!(window.ActiveXObject) && "ActiveXObject" in window) rs.version = "11"; return rs; }       if (!!window.StyleMedia && !!navigator.msSaveBlob) { rs.isEdge = true; match = ag.match(/Edge\/([0-9]+)\./);   rs.version = match ? match[1] : "1"; return rs; }         if (!!window.chrome) { rs.isChrome = true;
match = ag.match(/Chrom(e|ium)\/([0-9]+)\./); rs.version = match ? match[2] : "1"; return rs; } rs.isUnKnown = true; return rs; } function isFileList(inst) { return (inst instanceof FileList || Object.prototype.toString.call(inst) === "[object FileList]"); } function isFile(inst) { return (inst instanceof File || inst instanceof Blob || Object.prototype.toString.call(inst) === "[object File]"); } function ab2str(ab, encoding) { if ("TextDecoder" in window) { var dataView = new DataView(ab); var decoder = new TextDecoder(encoding); return decoder.decode(dataView);
} else {   console.log("Your browser doesn't support the text encoding API."); return String.fromCharCode.apply(null, new Uint8Array(ab)); } } function xml2str(src) { if (isDefined(src.xml)) return src.xml; else if (isDefined(src.innerHTML)) return src.innerHTML; else if (isDefined(src.documentElement)) { if (isDefined(src.documentElement.xml)) return src.documentElement.xml; if (isDefined(src.documentElement.innerHTML)) return src.documentElement.innerHTML; else if ("XMLSerializer" in window) { var serializer = new XMLSerializer();
return serializer.serializeToString(src); } else return src; } else return src; } function dic2kvList(dic) { var lst = []; if (dic) { for (var key in dic) { lst.push(encodeURIComponent(key) + "=" + encodeURIComponent(dic[key])); } } return lst; } function AJAX(url, method, callbacks, ret, data, headers, credential, async) { var xhr = (typeof XMLHttpRequest !== "undefined") ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"),   query = dic2kvList(data),   url = method.toUpperCase() != "POST" ? url + (query.length > 0 ? "?" + query.join("&") : "") : url;  
xhr["method"] = method.toUpperCase(); xhr.open(xhr["method"], url, async);           xhr.withCredentials = (credential === true);   xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest"); if (xhr["method"] == "POST") xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");   if (headers) for (var h in headers) { xhr.setRequestHeader(h, headers[h]); }     if (ret == "blob") xhr.responseType = "blob"; else if (ret == "json") xhr.responseType = "json"; else if (ret == "xml") { xhr.overrideMimeType('text/xml');
xhr.responseType = "document"; } else if (ret == "buffer") xhr.responseType = "arraybuffer"; else xhr.responseType = "text"; xhr.addEventListener("readystatechange", function (evt) {   if (xhr.readyState == this.HEADERS_RECEIVED) { if (callbacks && typeof callbacks.header == "function") { callbacks.header(); }               } }, false); xhr.addEventListener("loadstart", function (evt) { if (callbacks && typeof callbacks.start == "function") { callbacks.start(evt); } }, false); xhr.addEventListener("progress", function (evt) { if (callbacks && typeof callbacks.progress == "function") {
callbacks.progress(evt); } }, false); xhr.addEventListener("abort", function (evt) { if (callbacks && typeof callbacks.abort == "function") { callbacks.abort(); } }, false); xhr.addEventListener("error", function (evt) { if (callbacks && typeof callbacks.error == "function") {         callbacks.error(xhr.status, evt.message); } }, false); xhr.addEventListener("timeout", function (evt) { if (callbacks && typeof callbacks.timeout == "function") { callbacks.timeout(); } }, false); xhr.addEventListener("load", function (evt) { if (xhr.status < 400) {
if (callbacks && typeof callbacks.load == "function") { if (xhr["method"] && xhr["method"] == "HEAD") {             callbacks.load(""); } else {   switch (xhr.responseType) { case "arraybuffer": callbacks.load(xhr.response); break; case "document": callbacks.load(xhr.responseXML); break; case "json": callbacks.load(xhr.response); break; case "blob": callbacks.load(xhr.response); break; default: callbacks.load(xhr.responseText); break; } } } } else { if (callbacks && typeof callbacks.error == "function") {  
  var contentType = xhr.getResponseHeader("Content-Type"); if (contentType && contentType.indexOf("text/") == 0) {     if (xhr.responseType == "blob") { var fr = new FileReader(); fr.addEventListener("load", function (frevt) { var errbody = frevt.target.result; fr.removeEventListener("load", arguments.callee); callbacks.error(xhr.status, errbody); }); fr.readAsText(xhr.response); } else if (xhr.responseType == "arraybuffer") {   var errbody = ab2str(!xhr.response ? [] : xhr.response, "utf-8"); callbacks.error(xhr.status, errbody); } else if (xhr.responseType == "json") {
  callbacks.error(xhr.status, !xhr.response ? "Check the response body from the browser network tab in development mode." : xhr.response); } else if (xhr.responseType == "document") { callbacks.error(xhr.status, xml2str(xhr.response)); } else { callbacks.error(xhr.status, xhr.response); } } else { callbacks.error(xhr.status, xhr.response); } } } }, false); xhr.addEventListener("loadend", function (evt) { xhr.removeEventListener("readystatechange", arguments.callee); xhr.removeEventListener("loadstart", arguments.callee); xhr.removeEventListener("error", arguments.callee);
xhr.removeEventListener("abort", arguments.callee); xhr.removeEventListener("timeout", arguments.callee); xhr.removeEventListener("loadend", arguments.callee); }, false);   xhr.send((xhr["method"] == "POST" && query.length > 0) ? query.join("&") : null);   return xhr; } function getFileExtension(source) { if (!source) return ""; var lindex = source.lastIndexOf("."); return (lindex >= 0) ? source.substring(lindex) : ""; } function getLastPath(url) { if (!url) return ""; var lindex = url.lastIndexOf("/"); if (lindex < 0) return url;
if (lindex == (url.length - 1)) return ""; else return url.substring(lindex + 1); } function getParentPath(url) { if (!url) return ""; var lindex = url.lastIndexOf("/"); if (lindex < 0) return url; return url.substring(0, lindex); } function canonicalize(relative) { var lstSlashIndex = location.pathname.lastIndexOf("/"), parent = location.pathname.substring(0, lstSlashIndex); if (!relative) return location.href; while (parent || relative) { if (relative.indexOf("/") == 0) { parent = ""; relative = relative.substring(1); } else if (relative.indexOf("./") == 0) {
relative = relative.substring(2); } else if (relative.indexOf("../") == 0) { relative = relative.substring(3); parent = parent.substring(0, parent.lastIndexOf("/")); } else break; } return location.origin + parent + "/" + relative; } function clonejson(source, useFunc) { var cloned = {}; for (var p in source) { if (typeof p == "function") { if (useFunc) cloned[p] = source[p]; } else { cloned[p] = source[p]; } } return cloned; } function cloneArray(source) { var cloned = []; for (var i = 0, len = source.length; i < len; i++) { cloned.push(source[i]);
} return cloned; } function getFriendlySize(size, points) { if (size == 0) return "0 byte"; points = points || 1; for (var units = [" bytes", " KB", " MB", " GB", " TB"], i = 0; i < units.length; i++) { if (parseInt(size / 1024) == 0) { return (i > 0 ? size.toFixed(points) : size) + units[i]; } else { size = size / 1024; } } } function getFriendlySpeed(speed, points) { if (speed == 0) return "0 B/s"; points = points || 1; for (var units = [" B/s", " KB/s", " MB/s", " GB/s", " TB/s"], i = 0; i < units.length; i++) { if (parseInt(speed / 1024) == 0) {
return (i > 0 ? speed.toFixed(points) : speed) + units[i]; } else { speed = speed / 1024; } } } function msecToTimeFormat(duration, useMillisec) { if (duration == Infinity) { return "Infinity"; } else if (duration == 0) { return "00:00:00" + (useMillisec ? ".000" : ""); } else { var ms = duration % 1000; duration = (duration - ms) / 1000; var sec = duration % 60; duration = (duration - sec) / 60; var min = duration % 60; duration = (duration - min) / 60; var hr = (duration - min) / 60; return "" + ("00" + hr).substring(hr.toString().length) + ":" +
("00" + min).substring(min.toString().length) + ":" + ("00" + sec).substring(sec.toString().length) + (useMillisec ? "." + ("000" + ms).substring(ms.toString().length) : ""); } } function getRadians(degrees) { return degrees * Math.PI / 180; } function getDegrees(radians) { return radians * 180 / Math.PI; } function formatedDateTypeA(dt) { var y = "" + dt.getFullYear(), M = "" + (dt.getMonth() + 1), d = "" + dt.getDate(), h = "" + dt.getHours(), m = "" + dt.getMinutes(), s = "" + dt.getSeconds(); if (M.length < 2) M = '0' + M;
if (d.length < 2) d = '0' + d; return [y, M, d].join('-') + " " + [h, m, s].join(":"); } var USER_DATA_TYPE = { UNDEFINED: "undefined", STRING: "string", BOOLEAN: "boolean", NUMBER: "number", INTEGER: "integer", INTEGER_WITH_ZERO: "integer_zero", INTEGER_WITH_ONE: "integer_one", INTEGER_WITH_MINUSONE: "integer_minusone" }; function checkStrongDataType(hope, target) { if (typeof (target) === "undefined") { return (hope == USER_DATA_TYPE.UNDEFINED); } switch (hope) { case USER_DATA_TYPE.STRING: if (typeof(target) === "string" && target.length > 0) return true; else return false;
    case USER_DATA_TYPE.STRING_WITH_EMPTY: if (typeof(target) === "string" && target.length >= 0) return true; else return false;     case USER_DATA_TYPE.BOOLEAN: if (target === true || target === false) return true; else return false; case USER_DATA_TYPE.NUMBER: if (typeof(target) === "number" && isFinite(target)) return true; else return true;     case USER_DATA_TYPE.INTEGER_PLUS: if (typeof(target) === "number" && isFinite(target)) return (target - parseInt(target, 10)) == 0 && target > 0; else return false;  
    case USER_DATA_TYPE.INTEGER_WITH_ZERO: if (typeof(target) === "number" && isFinite(target)) return (target - parseInt(target, 10)) == 0 && target >= 0; else return false;         case USER_DATA_TYPE.INTEGER_WITH_ONE: if (typeof(target) === "number" && isFinite(target)) return (target - parseInt(target, 10)) == 0 && target >= 1; else return false;         case USER_DATA_TYPE.INTEGER_WITH_MINUSONE: if (typeof(target) === "number" && isFinite(target)) return (target - parseInt(target, 10)) == 0 && target >= -1; else return false;
        } return false; } var SETOPS = {   minus: function (a, b) { return a.filter(function (x) { return b.indexOf(x) < 0; }); },   union: function (a, b) {  var u = []; a.forEach(function (v, i) {  if (b.indexOf(v) < 0) { u.push(v); } }); b.forEach(function (v, i) {  if (u.indexOf(v) < 0) { u.push(v); } }); return u; },   intersect: function (a, b) { return a.filter(function (x) { return b.indexOf(x) >= 0; }); } }; var ResourceBundle = function () { this.bundle = null; }; ResourceBundle.prototype.init = function (bundle) { this.bundle = bundle;
}; ResourceBundle.prototype.get = function (key, defVal) { if (this.bundle[key] != undefined) return this.bundle[key]; else if (defVal) return defVal; else return null; }; function isHexaColor(color) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color); } function hexColorToRgba(color, alpha) { var c = color.replace('#', '').split(''); var r, g, b; if (c.length == 3) { c = [c[0], c[0], c[1], c[1], c[2], c[2]]; } c = c.join(''); r = parseInt(c.substring(0, 2), 16); g = parseInt(c.substring(2, 4), 16); b = parseInt(c.substring(4, 6), 16);
return sformat("rgba({0}, {1}, {2}, {3})", [r, g, b, alpha]); } function compareNumber(a, b) { if (typeof a == "number" && typeof b == "number") return a - b;       a = parseFloat((a + "").replace(/[,\s\xA0]+/g, "")); b = parseFloat((b + "").replace(/[,\s\xA0]+/g, "")); if (isNaN(a) || isNaN(b)) throw new Error("DX5: The parameters passed to the 'sortByNumber' function are not numbers."); return a - b; } function compareString(a, b) { a = (a + ""); b = (b + ""); return a.localeCompare(b); } 