/*
 * DEXTUploadX5 - SVG manipulation library
 * http://www.dextsolution.com
 *
 * Copyright DEVPIA Inc.
 */
function computeExpression(expr, p, g) { var sv = expr.toString(); var tokens = sv.split(/([\+\-]+)/g); if (tokens.length > 0) { var op = "+", num = 0, c = "", n = 0; for (var i = 0; i < tokens.length; i++) { c = tokens[i]; if (c == "+") { op = "+"; continue; } else if (c == "-") { op = "-"; continue; } else if (c.charAt(c.length - 1) == "%") { n = (p * parseFloat(c) / 100); } else if (c.charAt(0) == "{" && c.charAt(c.length - 1) == "}") { n = g[c.substring(1, c.length - 1)]; } else { n = parseFloat(c); }
switch (op) { case "+": num += n; break; case "-": num -= n; break; } } return num; } else return expr; } function computeExpressionUseCacheFunction(element, name, expr, p, g) { if (element.calculateExpression && element.calculateExpression[name]) { var uce = element.getAttributeNS(null, "disableCacheExpression"); if (!uce || uce != "disabled") { return element.calculateExpression[name](p, g); } } var sv = expr.toString(); var tokens = sv.split(/([\+\-]+)/g); if (tokens.length > 0) { var strExpression = ""; var op = "+", num = 0, c = "", n = 0;
for (var i = 0; i < tokens.length; i++) { c = tokens[i]; if (c == "+") { op = "+"; strExpression += "+"; continue; } else if (c == "-") { op = "-"; strExpression += "-"; continue; } else if (c.charAt(c.length - 1) == "%") { n = (p * parseFloat(c) / 100); strExpression += "(p*" + parseFloat(c) +"/100)"; } else if (c.charAt(0) == "{" && c.charAt(c.length - 1) == "}") { n = g[c.substring(1, c.length - 1)]; strExpression += "g['" + c.substring(1, c.length - 1) +"']"; } else { n = parseFloat(c); strExpression += parseFloat(c).toString(); }
switch (op) { case "+": num += n; break; case "-": num -= n; break; } if (!element.calculateExpression) element.calculateExpression = {}; element.calculateExpression[name] = new Function("p", "g", " return " + strExpression + ";"); } return num; } else return expr; } function getElementComputedSize(target) { var style = getComputedStyle(target), size = { w: 0, h: 0 }; if (style) { size.w = parseFloat(style.width) - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight); size.h = parseFloat(style.height) - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom); }
return size; } function parseLayoutStyle(attr) { var style = {}; if (!attr) return style; var tokens = attr.split(";"); for (var i = 0; i < tokens.length; i++) { var kv = tokens[i].split(":"); if (kv.length == 2) style[trim(kv[0])] = trim(kv[1]); } return style; } function relayoutDX5(target, w, h, dic) { if (target.localName != "g") { var layout = target.getAttributeNS(null, "layout-dx5"), v = 0; if (layout) { layout = parseLayoutStyle(layout); for (var n in layout) { v = computeExpressionUseCacheFunction(target, n, layout[n], (["x", "x1", "x2", "cx", "dx", "width"].indexOf(n) >= 0 ? w : h), dic); if ((n == "width" || n == "height") && v < 0) v = 0;
if (n == "width") w = v; else if (n == "height") h = v; target.setAttributeNS(null, n, v); } } w = (target.width && typeof(target.width.baseVal) != "undefined") ? target.width.baseVal.value : w; h = (target.height && typeof(target.height.baseVal) != "undefined") ? target.height.baseVal.value : h; } for (var i = 0, len = target.childNodes.length, child = null; i < len; i++) { child = target.childNodes[i]; if (child.nodeType === 1) { relayoutDX5(child, w, h, dic); } } } ;;(function (ns) { var SVG_NS = "http://www.w3.org/2000/svg"; var XLINK_NS = "http://www.w3.org/1999/xlink";
var helper = function () {}; helper.prototype.isXLink = function (val) { if (val && val.length > 6 && val.substring(0, 6) == "xlink:") return true; else return false; }; helper.prototype.mkTextNode = function (txt) { return document.createTextNode(txt); }; helper.prototype.getText = function (element) { if (element && element.textContent) return element.textContent; else return ""; }; helper.prototype.replaceText = function (element, text) { if (element && (element.nodeName == "text" || element.nodeName == "tspan" || element.nodeName == "title")) { element.textContent = text;
} }; helper.prototype.create = function (name, id, pack, child) { var element = document.createElementNS(SVG_NS, name); if (id) element.setAttribute("id", id); this.attrs(element, pack, false); if (child) element.appendChild(child); return element; }; helper.prototype.get = function (id) { return document.getElementById(getIdSharp(id, false)); }; helper.prototype.query = function (selector) { return document.querySelector(selector); }; helper.prototype.queryAll = function (selector) { return document.querySelectorAll(selector); };
helper.prototype.attr = function (element, name, val, appendable) { if (!element) { console.log("DX5: svg-helper attr call: element => " + element); console.log("DX5: svg-helper attr call: name => " + name); console.log("DX5: svg-helper attr call: val => " + val); console.log("DX5: svg-helper attr call: appendable => " + appendable); throw new Error("DX5: element is " + element); } if (typeof (val) == "undefined") { if (this.isXLink(name)) return element.getAttributeNS(XLINK_NS, name.substring(6)); else
return element.getAttributeNS(null, name); } else { if (appendable) { var oval = this.attr(element, name); if (oval && oval.length > 0) { val = oval + " " + val; } } if (this.isXLink(name)) element.setAttributeNS(XLINK_NS, name, val); else element.setAttributeNS(null, name, val); return this; } }; helper.prototype.removeAttr = function (element, name, val) { var oval = this.attr(element, name); if (oval && oval.length > 0) { var tokens = oval.split(" "); for (var i = 0; i < tokens.length;) { if (tokens[i] == val) { tokens.splice(i, 1);
} else { i++; } } oval = trim(tokens.join(" ")); } if (oval) { if (this.isXLink(name)) element.setAttributeNS(XLINK_NS, name.substring(6), oval); else element.setAttributeNS(null, name, oval); } return this; }; helper.prototype.attrs = function (element, pack, appendable) { if (!pack) return this; for (var name in pack) { var val = pack[name]; if (appendable) { var oval = this.attr(element, name); if (oval && oval.length > 0) { val = oval + " " + val; } } if (this.isXLink(name)) { element.setAttributeNS(XLINK_NS, name.substring(6), val); } else {
element.setAttributeNS(null, name, val); } } return this; }; var graphicElementNames = [ "circle", "ellipse", "image", "line", "path", "polygon", "polyline", "rect", "text", "use" ]; helper.prototype.isGraphicElement = function (target) { if (!target || !target.nodeName) return false; return (graphicElementNames.indexOf(target.nodeName.toLowerCase()) != -1); }; window[ns] = helper; })("SVGHelper"); 